### swift ä¸­å®ç°å¤šæ€çš„æ–¹å¼

1. å­ç±»å‹å’Œæ–¹æ³•é‡å†™ï¼šæ ¹æ®ç±»å‹çš„ä¸åŒï¼ŒåŒæ ·çš„æ–¹æ³•å‘ˆç°ä¸åŒçš„è¡Œä¸º

2. å‡½æ•°é‡è½½ï¼šä¸ºç±»å‹å¤šæ¬¡å†™ç»Ÿä¸€ä¸ªå‡½æ•°(å‚æ•°ç±»å‹ä¸åŒ)çš„è¡Œä¸ºï¼›

3. é€šè¿‡æ³›å‹æ¥å®ç°


> è¡¥å……ï¼šswift ä¸­ä¸€ä¸ªå®Œæ•´çš„å‡½æ•°åŒ…æ‹¬å‡½æ•°çš„åŸºæœ¬å(æ‹¬å·å‰é¢çš„éƒ¨åˆ†)ï¼Œä¹ŸåŒ…æ‹¬ä»–çš„å‚æ•°æ ‡ç­¾ï¼›å¦‚ é›†åˆç±»å‹çš„ `index(_:offsetBy:)`ï¼Œè¯¥å‡½æ•°æ¥æ‰‹ä¸¤ä¸ªå‚æ•°(ç”±å†’å·è¡¨ç¤º)

> å‡½æ•°ä¹Ÿæ˜¯å¼•ç”¨ç±»å‹

### å¯é€‰å€¼

#### 1. éšå¼è½¬æ¢ä¸ºå¯é€‰å€¼

Swift ä¼šåœ¨ç±»å‹æ¨æ–­ä¸ºOperationæ—¶å°†ä½ æ‰€å†™çš„ç±»å‹Tï¼Œéšå¼è½¬æ¢ä¸º Operation<T> (T?)ç±»å‹,å¦‚ä¸‹

```
let a: [Int?] = [1, 2, nil]
print("a = \(a)")
// a = [Optional(1), Optional(2), nil]

// æˆ–è€…

let a = [1, 2, nil]
print("a = \(a)")
// a = [Optional(1), Optional(2), nil]

```

> âŒ  å¯é€‰å€¼å¹¶æ²¡æœ‰éµå®ˆ Equatable åè®® âŒ Swift 4.2 åŠä»¥åç‰ˆæœ¬ä¸­ å·²ç»å®ç°äº† Equatable åè®®

![Optionalçš„Equatableåè®®](Optionalçš„Equatableåè®®.png)


### ç»“æ„ä½“

**ç»“æ„ä½“æ˜¯å€¼ç±»å‹ä½†ä»–ä»¬ä¸ä¸€å®šéƒ½æ˜¯å­˜å‚¨åœ¨æ ˆä¸Šçš„**

```
class MyClass {}

var cls = MyClass()

func counterFunc() -> (Int) -> String {
    var counter = 0
    return {i in
        print("cls    : \(Unmanaged.passUnretained(cls).toOpaque())")
        var i2 = i
        Swift.withUnsafePointer(to: &i2) { print("i2     : \($0)") }
        counter += i
        Swift.withUnsafePointer(to: &cls) { print("counter: \($0)") }
        return "running total:\(counter)"
    }
}

f(3)//running total:3
f(4)//running total:7
f(-1)
f(-3)

```

æ‰“å°ç»“æœï¼š

```
cls    : 0x0000600001ba43c0
i2     : 0x00007ffeeed48be0
counter: 0x0000000117526770
cls    : 0x0000600001ba43c0
i2     : 0x00007ffeeed48be0
counter: 0x0000000117526770
cls    : 0x0000600001ba43c0
i2     : 0x00007ffeeed48be0
counter: 0x0000000117526770
cls    : 0x0000600001ba43c0
i2     : 0x00007ffeeed48be0
counter: 0x0000000117526770
```

```
/*
 1. é—­åŒ… = å‡½æ•°\é—­åŒ…è¡¨è¾¾å¼ + æ•è·å˜é‡
 2. å‡½æ•°\è¡¨è¾¾å¼ ä¹Ÿæ˜¯å¼•ç”¨ç±»å‹
 æ€è€ƒ:
    1. ä¸ºä»€ä¹ˆ i2 çš„åœ°å€ä¼šä¸ä¼šå˜åŠ¨
    2. counter å­˜å‚¨åœ¨æ ˆä¸Šå—ï¼Ÿ
 */
```

> ??? counter å°†å­˜åœ¨äºå †ä¸Šè€Œéæ ˆä¸Š ???ã€‚æˆ‘ä»¬å¯ä»¥å¤šæ¬¡è°ƒç”¨ counterFuncï¼Œå¹¶ä¸”çœ‹åˆ° running total çš„è¾“å‡ºåœ¨å¢åŠ ï¼š
 
> Swift çš„ç»“æ„ä½“ä¸€èˆ¬è¢«å­˜å‚¨åœ¨æ ˆä¸Šï¼Œä¸è¿‡å¯å˜ç»“æ„ä½“é»˜è®¤æ˜¯å­˜å‚¨åœ¨å †ä¸Šçš„ï¼Œä½†å¤§å¤šæ•°æƒ…å†µä¸‹è¿™äº›å¯å˜ç»“æ„ä½“éƒ½ä¼šè¢«ç¼–è¯‘å™¨ä¼˜åŒ–å¹¶å­˜å‚¨åˆ°æ ˆä¸Šã€‚å½“ç¼–è¯‘å™¨ä¾¦æµ‹åˆ°ç»“æ„ä½“å˜é‡è¢«ä¸€ä¸ªå‡½æ•°é—­åˆçš„æ—¶å€™è¿™ç§ä¼˜åŒ–å°†ä¸å†ç”Ÿæ•ˆï¼Œæ­¤æ—¶å¯å˜ç»“æ„ä½“å­˜å‚¨åœ¨å †ä¸Š!

**å› ä¸ºé—­åŒ… (ä¹ŸåŒ…æ‹¬å†…éƒ¨å‡½æ•°) é€šè¿‡å¼•ç”¨çš„æ–¹å¼æ¥æ•è·å˜é‡**

> ä¸Šé¢ä¾‹å­ä¸­ï¼šcounter åœ¨é€€å‡º counterFun çš„ä½œç”¨åŸŸæ—¶ä»»ç„¶å­˜åœ¨ï¼(å› ä¸ºè¢«é€ƒé€¸é—­åŒ…æ•è·çš„å˜é‡éœ€è¦åœ¨æ ˆå¸§ä¹‹å¤–ä¾ç„¶å­˜åœ¨!)


`Swift` çš„ `copy-in` `copy-out` æ¨¡å‹ï¼Œ`å¼•ç”¨è°ƒç”¨`ä¼˜åŒ–ï¼Œå®˜æ–¹æ–‡æ¡£å¦‚ä¸‹ï¼š
 
  > As an optimization, when the argument is a value stored at a physical address in memory, the same memory location is used both inside and outside the function body. The optimized behavior is known as call by reference; it satisfies all of the requirements of the copy-in copy-out model while removing the overhead of copying. Write your code using the model given by copy-in copy-out, without depending on the call-by-reference optimization, so that it behaves correctly with or without the optimization.
 
`Swift` ä¸­å¼€å‘è€…æ²¡åŠæ³•çŸ¥é“å’Œå¹²é¢„ä½•æ—¶ä¼šå‘ç”Ÿç»“æ„ä½“çš„å¤åˆ¶ï¼Œè¿™äº›ç®€åŒ–ç»™äº†ç¼–è¯‘å™¨æ›´å¤šçš„å¯èƒ½æ€§ï¼Œæ¥æ’é™¤é‚£äº›ä¸å¿…è¦çš„å¤åˆ¶ï¼Œæˆ–è€…ä½¿ç”¨è§¦åº•å¼•ç”¨è€Œéå€¼çš„æ–¹å¼æ¥ä¼˜åŒ–ä¸€ä¸ªå¸¸é‡ç»“æ„ä½“  -- `Swiftè¿›é˜¶>ç»“æ„ä½“å’Œç±»>å€¼ç±»å‹`
 
ç¼–è¯‘å™¨æ‰€åšçš„å¯¹äºå€¼**ç±»å‹**çš„_å¤åˆ¶ä¼˜åŒ–_å’Œå€¼**è¯­ä¹‰**ç±»å‹çš„_å†™æ—¶å¤åˆ¶_è¡Œä¸ºå¹¶ä¸æ˜¯ä¸€å›äº‹ã€‚_å†™æ—¶å¤åˆ¶_éœ€è¦å¼€å‘è€…æ¥å®ç°  -- `Swiftè¿›é˜¶>ç»“æ„ä½“å’Œç±»>å€¼ç±»å‹`


### ç±»

> === ç”¨æ¥åˆ¤æ–­ä¸¤ä¸ªå˜é‡æ˜¯å¦å¼•ç”¨åŒä¸€ä¸ªå¯¹è±¡,ç”¨äºå¼•ç”¨çš„åˆ¤æ–­


### å‡½æ•°


**é—­åŒ… = é—­åŒ…è¡¨è¾¾å¼ + æ•è·å˜é‡**

**å‡½æ•°ä¹Ÿæ˜¯å¼•ç”¨ç±»å‹**

**é—­åŒ… (ä¹ŸåŒ…æ‹¬å†…éƒ¨å‡½æ•°) é€šè¿‡å¼•ç”¨çš„æ–¹å¼æ¥æ•è·å˜é‡ã€‚**

> åœ¨åº•å±‚ï¼Œå®ä¾‹æ–¹æ³•ä¼šè¢«å¤„ç†ä¸ºè¿™æ ·ä¸€ä¸ªå‡½æ•°ï¼šå¦‚æœç»™å®šæŸä¸ªå®ä¾‹ï¼Œå®ƒå°†è¿”å›å¦ä¸€ä¸ªå¯ä»¥åœ¨è¯¥å®ä¾‹ä¸Šè¿›è¡Œæ“ä½œçš„å‡½æ•°ã€‚
> cls.printFunc å®é™…ä¸Šåªæ˜¯ MyClass.printFunc(cls) çš„å¦ä¸€ç§å†™æ³•
> ä¸¤ç§è¡¨è¾¾å¼è¿”å›çš„éƒ½æ˜¯ç±»å‹ä¸º (Int) -> () çš„å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°å¼ºå¼•ç”¨äº† cls å®ä¾‹.


#### inout å‚æ•°

**ä¸€. inout å‚æ•°è™½ç„¶ä½¿ç”¨&ï¼Œä½†è¿™å¹¶ä¸æ˜¯ä¼ é€’å¼•ç”¨(åŒºåˆ«äºcå’Œc++)ï¼š**

> å®˜æ–¹æ–‡æ¡£: inout å‚æ•°å°†ä¸€ä¸ªå€¼ä¼ é€’ç»™å‡½æ•°ï¼Œå‡½æ•°å¯ä»¥æ”¹å˜è¿™ä¸ªå€¼ï¼Œç„¶åå°†åŸæ¥çš„å€¼æ›¿æ¢æ‰ï¼Œå¹¶ä»å‡½æ•°ä¸­ä¼ å‡ºã€‚

> ç¼–è¯‘å™¨ **å¯èƒ½** ä¼šæŠŠ `inout` å˜é‡ä¼˜åŒ–ä¸ºå¼•ç”¨ä¼ é€’ï¼Œè€Œéä¼ å…¥å’Œä¼ å‡ºæ—¶çš„å¤åˆ¶ã€‚ä½†ï¼Œæ–‡æ¡£å·²ç»æ˜ç¡®æŒ‡å‡ºæˆ‘ä»¬ä¸åº”è¯¥ä¾èµ– `inout` çš„è¿™ä¸ªè¡Œä¸ºã€‚



**äºŒ. åµŒå¥—å‡½æ•°å’Œ inout**

ä½ å¯ä»¥åœ¨åµŒå¥—å‡½æ•°ä¸­ä½¿ç”¨ `inout` å‚æ•°ï¼Œ `Swift` ä¾ç„¶ä¼šä¿è¯ä½ çš„ä½¿ç”¨æ˜¯å®‰å…¨çš„ã€‚

ä½†æ˜¯ `inout` å‚æ•°ä¸èƒ½å‚ä¸é€ƒé€¸

```
func escapeIncrement(value: inout Int) -> () -> () {
    func inc() {
        value += 1
    }
    return inc// Nested function cannot capture inout parameter and escape
}
```

**ä¸‰. & ä¸æ„å‘³ç€ inout çš„æƒ…å†µ**


#### è®¡ç®—å±æ€§


**çŸ­è·¯æ±‚å€¼** : å¦‚ `è¡¨è¾¾å¼A && è¡¨è¾¾å¼B` , å¦‚æœ `è¡¨è¾¾å¼A` ä¸º `false` åˆ™ `è¡¨è¾¾å¼B` å°†ä¸å†è¿›è¡Œæ±‚å€¼çš„æ“ä½œï¼›

çŸ­è·¯æ±‚å€¼çš„ä¾‹å­

```Swift
let evens = [2, 4, 6]

if !evens.isEmpty && evens[0] > 10 {
    print("xxx")
}
// æˆ–è€…
if let first = evens.first, first > 10 {
    print("yyy")
}

```


#### @escaping

> ä¸€ä¸ªè¢«ä¿å­˜åœ¨æŸä¸ªåœ°æ–¹ç­‰å¾…ç¨å€™(æ¯”å¦‚å‡½æ•°è¿”å›å)åœ¨è°ƒç”¨çš„é—­åŒ…å°±å«åš **é€ƒé€¸é—­åŒ…**

**é—­åŒ…é»˜è®¤æ˜¯éé€ƒé¿çš„ï¼Œæ‰€ä»¥ä½ æƒ³è¦ä¿å­˜ä¸€ä¸ªé—­åŒ…å°±éœ€è¦åœ¨å‚æ•°æ ‡è®°ä¸º `@escaping` **

ç¼–è¯‘å™¨ä¼šå¯¹å‚æ•°å½¢å¼çš„é—­åŒ…è¿›è¡ŒéªŒè¯ï¼Œå¦‚æœä½ çš„é—­åŒ…æ²¡æœ‰è¢«æ ‡è®°ä¸º `@escaping` ï¼Œç¼–è¯‘å™¨å°†ä¸å…è®¸ä½ ä¿å­˜è¿™ä¸ªé—­åŒ…(æˆ–è€…å°†ä»–è¿”å›ç»™è°ƒç”¨è€…!)



### å››. å­—ç¬¦ä¸²

> å¯»æ‰¾ `Character` è¾¹ç•Œèµ·å§‹ä½ç½®çš„å¯é æ–¹æ³•æ˜¯ä½¿ç”¨ Foundation ä¸­çš„ `rangeOfComposedCharacterSequenc:` æ–¹æ³•

```
extension String.Index {
    func samePositionOnCharacterBoundary(in str: String) -> String.Index {
        let  range = str.rangeOfComposedCharacterSequence(at: self)
        return range.lowerBound
    }
}

let family = "ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦"

let noCharacterBoundary = family.utf16.index(family.utf16.startIndex, offsetBy: 3)
// åœ¨å­—ç¬¦è§†å›¾ä¸­ï¼Œå¹¶éæœ‰æ•ˆçš„ä½ç½®
noCharacterBoundary.utf16Offset(in: family)//3
noCharacterBoundary < family.utf16.endIndex// true
if let idx = String.Index(noCharacterBoundary, within: family) {
    family[idx]
} else {
	 print("Error! No such index!")// Error! No such index!
}
// æœ‰æ•ˆä½ç½®
let validIndex = noCharacterBoundary.samePositionOnCharacterBoundary(in: family)
family[validIndex]// ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦

```

### æ³›å‹

`distance(from:to:)`æ–¹æ³•çš„å¤æ‚åº¦é—®é¢˜

**`RandomAccessCollection` ç±»å‹çš„é›†åˆ `distance` çš„æ“ä½œå¤æ‚åº¦ä¸º O(1)**

```
extension String {
    func tests() -> Int {
        let start = startIndex
        let end = endIndex
        // ç”±äº String ä¸æ˜¯ RandomAccessCollection ç±»å‹ï¼Œ
        // å› æ­¤ distance çš„å¤æ‚åº¦ä¸º O(n)ï¼Œn ä¸º from åˆ° end çš„é—´è·
        let result = distance(from: start, to: end)
        return result
    }
}

"1234".tests()
"ğŸ‘¨â€ğŸš’çˆ±ğŸ‘®â€â™€ï¸".tests()
"ğŸ‘¨â€ğŸš’çˆ±ğŸ‘®â€â™€ï¸".count

```

**é€šè¿‡åè®®è¿›è¡Œä»£ç å…±äº«æ¯”ç»§æ‰¿çš„ä¼˜åŠ¿**

* æˆ‘ä»¬ä¸éœ€è¦è¢«å¼ºåˆ¶ä½¿ç”¨æŸä¸ªçˆ¶ç±»
* æˆ‘ä»¬å¯ä»¥è®©å·²å­˜åœ¨çš„ç±»å‹æ»¡è¶³åè®®ã€‚å­ç±»æ— æ³•è¿½æº¯çš„æ–¹å¼å»æ”¹å˜ä»–çš„çˆ¶ç±»
* åè®®æ—¢å¯ä»¥ç”¨äºç±»ä¹Ÿå¯ä»¥ç”¨äºç»“æ„ä½“
* å½“å¤„ç†åè®®æ—¶ï¼Œæˆ‘ä»¬æ— éœ€ä½†ç³»æ–¹æ³•é‡å†™æˆ–è€…åœ¨æ­£ç¡®çš„äº‹ä»¶è°ƒç”¨ super è¿™æ ·çš„é—®é¢˜


### æ‚è®°

1. Swift API æŒ‡å—æ¨èä½ å¯¹æ‰€æœ‰å¤æ‚åº¦ä¸æ˜¯ O(1) çš„è®¡ç®—å±æ€§éƒ½åº”è¯¥åœ¨æ–‡æ¡£ä¸­å†™æ˜ï¼Œå› ä¸ºè°ƒç”¨è€…å¯èƒ½ä¼šå‡è®¾ä¸€ä¸ªè®¡ç®—å±æ€§çš„è€—æ—¶æ˜¯å¸¸æ•°æ—¶é—´ã€‚

2. `Sequenc` åè®®ä¸­çš„ `contains()`æ–¹æ³•åœ¨æ•°ç»„ä¸­çš„æ—¶é—´å¤æ‚åº¦ä¸º `O(n)`ï¼Œåœ¨ `set` ä¸­çš„å¤æ‚åº¦ä¸º `O(1)`

3. s


