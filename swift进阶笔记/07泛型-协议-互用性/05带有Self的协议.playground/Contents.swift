import Foundation
import UIKit


/// MARK: 存在容器

func f<C: CustomStringConvertible>(_ x: C) -> Int {
    return MemoryLayout.size(ofValue: x)
}

func g(_ x: CustomStringConvertible) -> Int {
    return MemoryLayout.size(ofValue: x)
}

f(5)// 8
g(5)// 40

/*
 8 字节和 40 字节的尺寸差别是怎么来的？因为 f 接受的是泛型参数，整数 5 会被直接传递给这个函数，而不需要经过任何包装。所以它的大小是 8 字节，也就是 64 位系统中 Int 的尺寸。对于 g，整数会被封装到一个存在容器中。对于普通的协议 (也就是没有被约束为只能由 class 实现的协议)，会使用不透明存在容器 (opaque existential container)。不透明存在容器中含有一个存储值的缓冲区 (大小为三个指针，也就是 24 字节)；一些元数据 (一个指针，8 字节)；以及若干个目击表 (0 个或者多个指针，每个 8 字节)。如果值无法放在缓冲区里，那么它将被存储到堆上，缓冲区里将变为存储引用，它将指向值在堆上的地址。元数据里包含关于类型的信息 (比如是否能够按条件进行类型转换等)。
 
 目击表是让动态派发成为可能的关键。它为一个特定的类型将协议的实现进行编码：对于协议中的每个方法，表中会包含一个指向特定类型中的实现的入口。有时候这被称为 vtable。
 不透明存在容器的尺寸取决于目击表个数的多少，每个协议会对应一个目击表。举例来说，Any 是空协议的类型别名，所以它完全没有目击表
 */


















